

/*Indexing -- for fast searching , for fast retrieving 
o(n) -  Binary Search or linear case

O(n) -- select * from customers where city="Delhi"
We have two types of indexing :
1) Clustured - The tables' data is stored along with the index itself when we apply a primary key in a database
   If you don't defing a PK -- then MySQL will  use the first unique key as clustured index in a table , if there is no unique key then it will create
   a hidden row-id as a clustured index..
   
   Fast one because it applied on a Primary key on a actual table itself

2) Non- clustured - the index is stored separately from the actual table data .
 It contains the column values  plus a pointer(row address / primary key)
 to the actual table row.
 
 Two look up requires (index+ table ) which is slower than the clustured one
 
 */
 
use wiprotraining;
create table customers(
customer_id int auto_increment primary key,
name varchar(100),
city varchar(100),
phone varchar(20)
);

insert into customers (name , city , phone) values
('Niti','Delhi','945495'),
('Nitin','Delhi','9675495'),
('Jatin','Agra','945566495'),
('Jiya','Bhimtal','944355495'),
('Kriti','Up','94235495');


Explain select * from customers where city='Delhi' and phoneno="";

create index idx_city on customers(city);

create index idx_name on customers(name);

create index idx_cityname on customers(city,name);

























`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
-- SQL  DDL  ( defining the structure of database and tables ), DML , DCL , TCL , DQL

create database wiprotraining;
use wiprotraining;
show tables;
-- DBMS  -- Data base management System -- MSAcess , XML , Excel -- File System -- No relationship -- Speed is slow for large data 
-- RDBMS -- Relational Database Management System -- stores data in tables  ,
-- tables are also linked with pk and fk, rules (Constraints) to ensure data accuracy ,
-- speed is faster because of indexing , MySQL , SQL Server , Oracle (PL/SQL) , PostgreSQL
-- Primary key  / Foreign key 

-- keyterms we use here tuples as rows -- ( cardinality ( total no of rows)
--     Attributes as column names  --- (Degree (total no of columns))
drop table todotask; -- It will the entire structure of a table with records
create table todotask
(
id int primary key 	
title varchar(255),
start_date Date,
due_date Date
);
-- table is a set of rows and columns
describe todotask;
select * from todotask;

insert into todotask values(101,'Learn Java' , '2025-08-05' , '2025-09-20');
insert into todotask values(102,'Coding Challenges' , '2025-08-05' , '2025-09-20');

-- Each task has a checklist
create table checklist
(
id int,
task_id int ,
title varchar(255) not null,
is_completed boolean not null default false,
primary key (id,task_id), -- composite key
foreign key(task_id) references todotask(id) on delete cascade
);
-- If you delete the task from todotask table then the data from child table i.e. checklist related data will also be deleted

describe checklist;
describe todotask;


truncate  table states; -- deleting all records at once but not a structure of a table 
truncate table cities;
drop table states;
drop table cities;
create table states
(statecode char(2) primary key,
name varchar(30));
insert into states values("IN", "Delhi");
describe states;
create table cities
(name varchar(30) , state_co char(2),
foreign key(state_co) references states(statecode) on delete cascade);
insert into cities values("Agra" , "IN");
describe cities;
select * from cities;
select * from states ; 

create table pin
(name varchar(34) ,state_co char(2),cities_id int ,
foreign key (id) references cities(id));
-- Error Code: 1451. Cannot delete or update a parent row: a foreign key constraint fails (`wiprotraining`.`cities`, CONSTRAINT `cities_ibfk_1` FOREIGN KEY (`state_co`) REFERENCES `states` (`statecode`))

set foreign_key_checks=1;

delete from states where statecode="IN"; -- delete a particular records matching with the conditions


select * from states;
update states set name="UP" where statecode= "IN";

select * from states where statecode="IN";
--  truncate , delete , drop , update , create , insert ,select ,foreign_key_checks , On delete cascade










````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````



````````````````````````````````````````````````````````````````````````````````````````
-- SQL  DDL  ( defining the structure of database and tables ), DML , DCL , TCL , DQL

create database wiprotraining;
use wiprotraining;
show tables;
-- DBMS  -- Data base management System -- MSAcess , XML , Excel -- File System -- No relationship -- Speed is slow for large data 
-- RDBMS -- Relational Database Management System -- stores data in tables  ,
-- tables are also linked with pk and fk, rules (Constraints) to ensure data accuracy ,
-- speed is faster because of indexing , MySQL , SQL Server , Oracle (PL/SQL) , PostgreSQL
-- Primary key  / Foreign key 

-- keyterms we use here tuples as rows -- ( cardinality ( total no of rows)
--     Attributes as column names  --- (Degree (total no of columns))
drop table todotask; -- It will the entire structure of a table with records
create table todotask
(
id int primary key ,
title varchar(255),
start_date Date,
due_date Date
);
-- table is a set of rows and columns
describe todotask;
select * from todotask;

insert into todotask values(101,'Learn Java' , '2025-08-05' , '2025-09-20');
insert into todotask values(102,'Coding Challenges' , '2025-08-05' , '2025-09-20');

-- Each task has a checklist
create table checklist
(
id int,
task_id int ,
title varchar(255) not null,
is_completed boolean not null default false,
primary key (id,task_id), -- composite key
foreign key(task_id) references todotask(id) on delete cascade
);
-- If you delete the task from todotask table then the data from child table i.e. checklist related data will also be deleted

describe checklist;
describe todotask;
````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````

`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````

```````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````

-- you have two different tables -- employee and department
-- who are the employees earning more than the department's  avg salary 

create  table departments
(department_id int primary key , department_name varchar(100));

create table employee
(employee_id int primary key,
employee_name varchar(100),
department_id int,
salary decimal(10,2),
foreign key (department_id) references departments(department_id));

insert into departments values (1,'sales'),
(2,'engineering'),
(3, 'hr') ;


insert into employee values(101, 'jiya' ,1,45454),
(102, 'preeti' ,1,35454),
(103, 'shubham' ,2,25454),
(104, 'Aman' ,2,45344),
(105, 'krishna ' ,3,15554),
(106, 'Anjali' ,3,65454);

-- employee earning more than their department average salary

-- self join with correlated subquery 
select employee_id ,employee_name from employee e where salary > 
 (select avg(salary) from employee e2 where e2.department_id = e.department_id);

-- correlated subquery run multiple times 
-- employees from sales department 

select employee_name , department_id from employee where department_id in (
select department_id from departments where department_name = 'Engineering');
;
select e.employee_name from employee e join departments d on e.department_id = d.department_id where d.department_name='Sales' ;

/* comparing values with an aggregate function -- subquery as compare to join
working with multiple tables and complex relationships you have created or when you have a large dataset  -- Join will be better instead of subquery will be slow
*/

-- employee  , product , order 

-- optimization exist and in  for large datasets when we are not sure then use exists 
-- Exists will stop searching once a match is found while in checks all records 
select employee_name from employee e where exists(
select 1 from departments d where d.department_id = e.department_id);

select * from cities where state in('up','delhi'); -- it is for category
select * from cities where pincode between 1002 and 1005 -- for specifying the range




